// Code generated by go-swagger; DO NOT EDIT.

package recipe

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new recipe API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for recipe API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddIngredientsToRecipe saves a particular recipe s ingredients en masse
*/
func (a *Client) AddIngredientsToRecipe(params *AddIngredientsToRecipeParams) (*AddIngredientsToRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddIngredientsToRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AddIngredientsToRecipe",
		Method:             "POST",
		PathPattern:        "/recipe/{recipeId}/ingredient",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddIngredientsToRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddIngredientsToRecipeOK), nil

}

/*
CopyRecipeExactly allows you to make a copy of a recipe which you re free to make changes to as if it were your own
*/
func (a *Client) CopyRecipeExactly(params *CopyRecipeExactlyParams, authInfo runtime.ClientAuthInfoWriter) (*CopyRecipeExactlyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCopyRecipeExactlyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CopyRecipeExactly",
		Method:             "GET",
		PathPattern:        "/recipe/copy/{recipeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CopyRecipeExactlyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CopyRecipeExactlyOK), nil

}

/*
CopyRecipeToMyRecipesWithChanges allows you to make a copy of a recipe which you re free to make changes to as if it were your own
*/
func (a *Client) CopyRecipeToMyRecipesWithChanges(params *CopyRecipeToMyRecipesWithChangesParams, authInfo runtime.ClientAuthInfoWriter) (*CopyRecipeToMyRecipesWithChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCopyRecipeToMyRecipesWithChangesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CopyRecipeToMyRecipesWithChanges",
		Method:             "POST",
		PathPattern:        "/recipe/copy/{recipeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CopyRecipeToMyRecipesWithChangesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CopyRecipeToMyRecipesWithChangesOK), nil

}

/*
DeleteIngredientFromRecipe deletes an ingredient from a recipe
*/
func (a *Client) DeleteIngredientFromRecipe(params *DeleteIngredientFromRecipeParams) (*DeleteIngredientFromRecipeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIngredientFromRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteIngredientFromRecipe",
		Method:             "DELETE",
		PathPattern:        "/recipe/{recipeId}/ingredient/{ingredient-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteIngredientFromRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteIngredientFromRecipeCreated), nil

}

/*
DeleteRecipe removes one of your recipes
*/
func (a *Client) DeleteRecipe(params *DeleteRecipeParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRecipe",
		Method:             "DELETE",
		PathPattern:        "/recipe/{recipeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecipeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecipeOK), nil

}

/*
EditIngredientForRecipe saves a particular recipe s ingredients en masse
*/
func (a *Client) EditIngredientForRecipe(params *EditIngredientForRecipeParams) (*EditIngredientForRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEditIngredientForRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EditIngredientForRecipe",
		Method:             "PUT",
		PathPattern:        "/recipe/{recipeId}/ingredient",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &EditIngredientForRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EditIngredientForRecipeOK), nil

}

/*
GetCategoriesForRecipe gets a list of the categories the food belongs to
*/
func (a *Client) GetCategoriesForRecipe(params *GetCategoriesForRecipeParams) (*GetCategoriesForRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCategoriesForRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCategoriesForRecipe",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/categories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCategoriesForRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCategoriesForRecipeOK), nil

}

/*
GetImageQRCodePNG gets the q r code image
*/
func (a *Client) GetImageQRCodePNG(params *GetImageQRCodePNGParams) (*GetImageQRCodePNGOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetImageQRCodePNGParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetImageQRCodePNG",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/qr-image/png",
		ProducesMediaTypes: []string{"image/png"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetImageQRCodePNGReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetImageQRCodePNGOK), nil

}

/*
GetIngredientFromRecipeWithNutrition gets a particular ingredient in a recipe
*/
func (a *Client) GetIngredientFromRecipeWithNutrition(params *GetIngredientFromRecipeWithNutritionParams) (*GetIngredientFromRecipeWithNutritionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIngredientFromRecipeWithNutritionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIngredientFromRecipeWithNutrition",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/ingredient/{ingredient-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIngredientFromRecipeWithNutritionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIngredientFromRecipeWithNutritionOK), nil

}

/*
GetIngredientsForRecipe gets a particular recipe s ingredients
*/
func (a *Client) GetIngredientsForRecipe(params *GetIngredientsForRecipeParams) (*GetIngredientsForRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIngredientsForRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIngredientsForRecipe",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/ingredient",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIngredientsForRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIngredientsForRecipeOK), nil

}

/*
GetMyRecipes gets all of the recipes owned by the currently logged in or authorised user include the recipe s nutrition per portion
*/
func (a *Client) GetMyRecipes(params *GetMyRecipesParams, authInfo runtime.ClientAuthInfoWriter) (*GetMyRecipesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMyRecipesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetMyRecipes",
		Method:             "GET",
		PathPattern:        "/recipe",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetMyRecipesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetMyRecipesOK), nil

}

/*
GetNutritionLabelCSS gets the nutrition label CSS
*/
func (a *Client) GetNutritionLabelCSS(params *GetNutritionLabelCSSParams) (*GetNutritionLabelCSSOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelCSSParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelCss",
		Method:             "GET",
		PathPattern:        "/css/nutritionLabel.css",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelCSSReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelCSSOK), nil

}

/*
GetNutritionLabelHTML gets HTML source which draws a dynamic javascript operated version of the nutrition label you should pass the header accept text html in the request to receive the HTML text in raw requests to the server
*/
func (a *Client) GetNutritionLabelHTML(params *GetNutritionLabelHTMLParams) (*GetNutritionLabelHTMLOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelHTMLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelHtml",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/nutrition-label/html",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelHTMLReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelHTMLOK), nil

}

/*
GetNutritionLabelHTMLDynamicSnippet gets HTML source which draws a dynamic javascript operated version of the nutrition label this produces a div with the nutrition label drawn inside it the nutrients can be extended to show the food s producing the total food nutrition
*/
func (a *Client) GetNutritionLabelHTMLDynamicSnippet(params *GetNutritionLabelHTMLDynamicSnippetParams) (*GetNutritionLabelHTMLDynamicSnippetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelHTMLDynamicSnippetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelHtmlDynamicSnippet",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/nutrition-label/dynamic-snippet",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelHTMLDynamicSnippetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelHTMLDynamicSnippetOK), nil

}

/*
GetNutritionLabelHTMLStaticSnippet gets HTML source which draws a static version of the nutrition label this produces a div with the nutrition label drawn inside it
*/
func (a *Client) GetNutritionLabelHTMLStaticSnippet(params *GetNutritionLabelHTMLStaticSnippetParams) (*GetNutritionLabelHTMLStaticSnippetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelHTMLStaticSnippetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelHtmlStaticSnippet",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/nutrition-label/static-snippet",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelHTMLStaticSnippetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelHTMLStaticSnippetOK), nil

}

/*
GetNutritionLabelJs gets HTML source which draws a dynamic javascript operated version of the nutrition label you should pass the header accept text html in the request to receive the HTML text in raw requests to the server
*/
func (a *Client) GetNutritionLabelJs(params *GetNutritionLabelJsParams) (*GetNutritionLabelJsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelJsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelJs",
		Method:             "GET",
		PathPattern:        "/js/nutritionLabel.js",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelJsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelJsOK), nil

}

/*
GetNutritionTipsForRecipe gets a list of the nutrient tips for a particular recipe
*/
func (a *Client) GetNutritionTipsForRecipe(params *GetNutritionTipsForRecipeParams) (*GetNutritionTipsForRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionTipsForRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionTipsForRecipe",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/nutrition-tip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionTipsForRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionTipsForRecipeOK), nil

}

/*
GetRecipeByID gets a recipe object and include the total recipe nutrition
*/
func (a *Client) GetRecipeByID(params *GetRecipeByIDParams) (*GetRecipeByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRecipeByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRecipeByID",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecipeByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecipeByIDOK), nil

}

/*
GetRecipeCSV creates a detailed c s v file from a recipe includes data on the calories per portion and calorie for each ingredient in the recipe
*/
func (a *Client) GetRecipeCSV(params *GetRecipeCSVParams, authInfo runtime.ClientAuthInfoWriter) (*GetRecipeCSVOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRecipeCSVParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRecipeCSV",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/csv",
		ProducesMediaTypes: []string{"text/csv"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecipeCSVReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecipeCSVOK), nil

}

/*
GetRecipeFoodNames gets a recipe object s food names
*/
func (a *Client) GetRecipeFoodNames(params *GetRecipeFoodNamesParams) (*GetRecipeFoodNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRecipeFoodNamesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRecipeFoodNames",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/food",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecipeFoodNamesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecipeFoodNamesOK), nil

}

/*
GetRecipeIngredientNames gets a list of the common names for a particular recipe
*/
func (a *Client) GetRecipeIngredientNames(params *GetRecipeIngredientNamesParams) (*GetRecipeIngredientNamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRecipeIngredientNamesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRecipeIngredientNames",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/ingredient-names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecipeIngredientNamesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecipeIngredientNamesOK), nil

}

/*
GetRecipePNG gets the URL for a recipe s image
*/
func (a *Client) GetRecipePNG(params *GetRecipePNGParams) (*GetRecipePNGOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRecipePNGParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRecipePNG",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/image",
		ProducesMediaTypes: []string{"image/png"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecipePNGReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecipePNGOK), nil

}

/*
LatestRecipes gets the latest recipe object with nutrition data and include the nutrition information for the ingredients in this object
*/
func (a *Client) LatestRecipes(params *LatestRecipesParams) (*LatestRecipesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLatestRecipesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LatestRecipes",
		Method:             "GET",
		PathPattern:        "/recipe/latest",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LatestRecipesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LatestRecipesOK), nil

}

/*
ListIngredientsWithNutrition gets a list of ingredients in a recipe
*/
func (a *Client) ListIngredientsWithNutrition(params *ListIngredientsWithNutritionParams) (*ListIngredientsWithNutritionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIngredientsWithNutritionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListIngredientsWithNutrition",
		Method:             "GET",
		PathPattern:        "/recipe/{recipeId}/ingredient/nutrition",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListIngredientsWithNutritionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListIngredientsWithNutritionOK), nil

}

/*
NarrowSearchRecipe searches for recipe data and receive only specific fields back nutritional information isn t available as only the recipe object is included in searches and response
*/
func (a *Client) NarrowSearchRecipe(params *NarrowSearchRecipeParams) (*NarrowSearchRecipeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNarrowSearchRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "NarrowSearchRecipe",
		Method:             "GET",
		PathPattern:        "/recipe/narrow-search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NarrowSearchRecipeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*NarrowSearchRecipeOK), nil

}

/*
PagedSearchRecipes searches for recipes and include paging info in the response
*/
func (a *Client) PagedSearchRecipes(params *PagedSearchRecipesParams) (*PagedSearchRecipesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPagedSearchRecipesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PagedSearchRecipes",
		Method:             "GET",
		PathPattern:        "/recipe/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PagedSearchRecipesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PagedSearchRecipesOK), nil

}

/*
SaveChangesForIngredient makes changes to a particular ingredient in a recipe
*/
func (a *Client) SaveChangesForIngredient(params *SaveChangesForIngredientParams) (*SaveChangesForIngredientOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSaveChangesForIngredientParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SaveChangesForIngredient",
		Method:             "PUT",
		PathPattern:        "/recipe/{recipeId}/ingredient/{ingredient-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SaveChangesForIngredientReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SaveChangesForIngredientOK), nil

}

/*
SaveRecipe saves changes to a recipe
*/
func (a *Client) SaveRecipe(params *SaveRecipeParams, authInfo runtime.ClientAuthInfoWriter) (*SaveRecipeOK, *SaveRecipeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSaveRecipeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SaveRecipe",
		Method:             "PUT",
		PathPattern:        "/recipe/{recipeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SaveRecipeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *SaveRecipeOK:
		return value, nil, nil
	case *SaveRecipeCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

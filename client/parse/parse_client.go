// Code generated by go-swagger; DO NOT EDIT.

package parse

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new parse API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for parse API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
GetNutritionForSingleParsedPlainTextIngredient retrieves a list of ingredients and nutritional info
*/
func (a *Client) GetNutritionForSingleParsedPlainTextIngredient(params *GetNutritionForSingleParsedPlainTextIngredientParams, authInfo runtime.ClientAuthInfoWriter) (*GetNutritionForSingleParsedPlainTextIngredientOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionForSingleParsedPlainTextIngredientParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionForSingleParsedPlainTextIngredient",
		Method:             "GET",
		PathPattern:        "/parse/nutrition/ingredient/{ingredient-line}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionForSingleParsedPlainTextIngredientReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionForSingleParsedPlainTextIngredientOK), nil

}

/*
GetNutritionLabelFromPlainIngredientsDynamicHTML gets HTML source which draws a dynamic javascript operated version of the nutrition label from plain text ingredients passed to the endpoint as a json array where each item in the array is an ingredient line you should pass the header accept text html in the request to receive the HTML text in raw requests to the server
*/
func (a *Client) GetNutritionLabelFromPlainIngredientsDynamicHTML(params *GetNutritionLabelFromPlainIngredientsDynamicHTMLParams, authInfo runtime.ClientAuthInfoWriter) (*GetNutritionLabelFromPlainIngredientsDynamicHTMLOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelFromPlainIngredientsDynamicHTMLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelFromPlainIngredientsDynamicHtml",
		Method:             "POST",
		PathPattern:        "/parse/nutrition-label/dynamic-html",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelFromPlainIngredientsDynamicHTMLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelFromPlainIngredientsDynamicHTMLOK), nil

}

/*
GetNutritionLabelFromPlainIngredientsHTML gets HTML source which draws a static HTML version of the nutrition label from plain text ingredients passed to the endpoint as a json array where each item in the array is an ingredient line you should pass the header accept text html in the request to receive the HTML text in raw requests to the server
*/
func (a *Client) GetNutritionLabelFromPlainIngredientsHTML(params *GetNutritionLabelFromPlainIngredientsHTMLParams, authInfo runtime.ClientAuthInfoWriter) (*GetNutritionLabelFromPlainIngredientsHTMLOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNutritionLabelFromPlainIngredientsHTMLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetNutritionLabelFromPlainIngredientsHtml",
		Method:             "POST",
		PathPattern:        "/parse/nutrition-label/html",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNutritionLabelFromPlainIngredientsHTMLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNutritionLabelFromPlainIngredientsHTMLOK), nil

}

/*
IncorrectIngredientParsing as human can notify the server when a parsed ingredient is wrong
*/
func (a *Client) IncorrectIngredientParsing(params *IncorrectIngredientParsingParams) (*IncorrectIngredientParsingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIncorrectIngredientParsingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "IncorrectIngredientParsing",
		Method:             "GET",
		PathPattern:        "/parse/notify-error/{parsedId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &IncorrectIngredientParsingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*IncorrectIngredientParsingOK), nil

}

/*
ParseManyPlainTextIngredientLineRequest retrieves a list of ingredients and nutritional info
*/
func (a *Client) ParseManyPlainTextIngredientLineRequest(params *ParseManyPlainTextIngredientLineRequestParams) (*ParseManyPlainTextIngredientLineRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseManyPlainTextIngredientLineRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParseManyPlainTextIngredientLineRequest",
		Method:             "POST",
		PathPattern:        "/debug/parse/ingredients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseManyPlainTextIngredientLineRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParseManyPlainTextIngredientLineRequestOK), nil

}

/*
ParsePlainTextIngredientLines retrieves a list of ingredients and nutritional info
*/
func (a *Client) ParsePlainTextIngredientLines(params *ParsePlainTextIngredientLinesParams, authInfo runtime.ClientAuthInfoWriter) (*ParsePlainTextIngredientLinesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParsePlainTextIngredientLinesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParsePlainTextIngredientLines",
		Method:             "POST",
		PathPattern:        "/parse/ingredients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParsePlainTextIngredientLinesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParsePlainTextIngredientLinesOK), nil

}

/*
ParseRecipeByURLGet takes a URL of a recipe on the internet a sous bot will parse it if it can and then spit out a recipe object as the result
*/
func (a *Client) ParseRecipeByURLGet(params *ParseRecipeByURLGetParams) (*ParseRecipeByURLGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseRecipeByURLGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParseRecipeByUrlGet",
		Method:             "GET",
		PathPattern:        "/parse/via-url/recipe/{recipe-url}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseRecipeByURLGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParseRecipeByURLGetOK), nil

}

/*
ParseRecipeByURLPost takes a URL of a recipe on the internet a sous bot will parse it if it can and then spit out a recipe object as the result
*/
func (a *Client) ParseRecipeByURLPost(params *ParseRecipeByURLPostParams, authInfo runtime.ClientAuthInfoWriter) (*ParseRecipeByURLPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseRecipeByURLPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParseRecipeByUrlPost",
		Method:             "POST",
		PathPattern:        "/parse/via-url/recipe",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseRecipeByURLPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParseRecipeByURLPostOK), nil

}

/*
ParseRecipeViaPageContent takes a URL of a recipe on the internet a sous bot will parse it if it can and then spit out a recipe object as the result
*/
func (a *Client) ParseRecipeViaPageContent(params *ParseRecipeViaPageContentParams, authInfo runtime.ClientAuthInfoWriter) (*ParseRecipeViaPageContentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseRecipeViaPageContentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParseRecipeViaPageContent",
		Method:             "POST",
		PathPattern:        "/parse/via-page-content/recipe",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseRecipeViaPageContentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParseRecipeViaPageContentOK), nil

}

/*
ParseSinglePlainTextIngredientLineRequest retrieves a list of ingredients and nutritional info
*/
func (a *Client) ParseSinglePlainTextIngredientLineRequest(params *ParseSinglePlainTextIngredientLineRequestParams) (*ParseSinglePlainTextIngredientLineRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewParseSinglePlainTextIngredientLineRequestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ParseSinglePlainTextIngredientLineRequest",
		Method:             "GET",
		PathPattern:        "/parse/ingredients/{ingredient-line}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ParseSinglePlainTextIngredientLineRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ParseSinglePlainTextIngredientLineRequestOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
